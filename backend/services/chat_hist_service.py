from model.chat_history_model import chat_history
from utils.db import db
from model.job_model import jobs
from utils.db import db
from sqlalchemy import select, text
import pandas as pd
import traceback


class ChatService:
    @staticmethod
    def create_chat(cust_id, question, topic, keywords, response):
        """
        - Create a new chat record in the database
        = params:
            + cust_id (int): customer ID
            + question (str): message from customer (raw)
            + topic (str): topic message (amount, trivia, salary)
            + keywords (str): cleaned text
            + response (str): generated by the system (sql result)
        """
        new_chat = chat_history(customer_id = cust_id, question = question, topic = topic, keywords = keywords, response = response)
        db.session.add(new_chat)
        db.session.commit()
        return new_chat #object including that row data
    
    def get_reponse(query_sent, cal_on, topic, location, date):
        """
        - interact with the database via the query text to collect the data for the response
        - params: query_sent (str), cal_on (str), topic(str), location (str), date (str)
        - return: respone (str)
        """
        #call API

        result = db.session.execute(text(query_sent)) #execute the query
        df = pd.DataFrame.from_dict(result). astype(str) #convert to dataframe, convert data type of columns to string
        
        if location != "":
            location = ' in ' + location #formating location phrase for the response

        def extract_value(column_name, topic, location, date):
            """
            - generate response displayed to user
            - params:
                + column_name (str): column whose value will be displayed
                + topic (str): main topic of the message
                + location (str)
                + date (str)
            -return: response (str)

            """
            values = df[column_name].tolist()
            response = f'The {topic.lower()}{location} {date} is '
            if len(values) == 1:
                response += f' {" ".join(values)}.'
            elif len(values) > 1:
                print("in process of updating.")
            return response

        try:
            match topic:
                case 'amount':
                    response = extract_value('Count_', " ".join([topic, "of job positions"]), location, date)
                case 'salary':
                    response = extract_value('AVG_', " ".join([cal_on, topic]), location, date)                        

        except Exception as e:
            print(f"An error of type {type(e)} occurred: {e} {traceback.extract_tb(e.__traceback__)[0].lineno}")
            response = 'Sorry, this information has not been updated in our system...'
        
        return " ".join(response.split())
    
    def update_rating (chat_id, rating):
        """
        - save how the customer rates their satisfaction to the given response
        - params: rating(int)
        - return: update 
        """
        try:
            update = chat_history.query.filter_by(chat_id=chat_id).first()
            update.rating = rating
            db.session.commit()
            print('a')
        except Exception as e:
            print(f"An error of type {type(e)} occurred: {e} {traceback.extract_tb(e.__traceback__)[0].lineno}")
        
        return update #object including that row data

    def furtherrequest(type_):
        """
        - execute the SQL query to return the response
        - param:
            + type_(int): type of request
                *1: amount of open job positions by locations
                *2: amount of open job positions by industry
                *3: average salary by locations
                *4: avearge salary by industry

        - return:
            + result_list (list): list of values
        """
        topic, keyword = "", ""
        match type_:
            case 1:
                topic = 'amount'
                keyword = 'location'
                sql = "SELECT job_area_name AS name_, COUNT(*) AS value_s FROM jobs WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) AND is_hide = 0 AND job_phase = 'Open' GROUP BY job_area_name ORDER BY COUNT(*) DESC LIMIT 5"
            case 2:
                topic = 'amount'
                keyword = 'industry'
                sql = "SELECT `job_industry_name` AS name_,	COUNT(*) AS value_s FROM jobs WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) AND is_hide = 0 AND job_phase = 'Open' GROUP BY job_industry_name ORDER BY COUNT(*) DESC LIMIT 5"
            case 3: 
                topic = 'salary'
                keyword = 'location'
                sql = "SELECT `job_area_name` AS name_, CONCAT(FORMAT(ROUND(AVG(`job_minsalary`), 0), 0), '-', FORMAT(ROUND(AVG(`job_minsalary`), 0), 0)) AS value_s FROM jobs WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) AND is_hide = 0 GROUP BY job_area_name ORDER BY (AVG(`job_minsalary`) + AVG(`job_minsalary`)) / 2 DESC LIMIT 5"
            case 4:
                topic = 'salary'
                keyword = 'industry'
                sql = "SELECT `job_industry_name` AS name_, CONCAT(FORMAT(ROUND(AVG(`job_minsalary`), 0), 0), '-', FORMAT(ROUND(AVG(`job_minsalary`), 0), 0)) AS value_s FROM jobs WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR) AND is_hide = 0 GROUP BY job_industry_name ORDER BY (AVG(`job_minsalary`) + AVG(`job_minsalary`)) / 2 DESC LIMIT 5"
 
        result = db.session.execute(text(sql)) #execute the query
        result = result.mappings().all() #convert to a list
        
        return {'result':result, 'topic':topic, 'keyword': keyword}